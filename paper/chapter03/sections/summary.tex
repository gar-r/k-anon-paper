In this chapter we have briefly introduced the Go programming language, and why we think it is a good choice for implementing the anonymization algorithm.

Then we took a high-level overview of the algorithm implementation, including the different pieces, and how they work together. After which we discussed in what format the algorithm will accept the input data. We gave a detailed description of how generalization works, and how one can use the built-in generalizers or implement a custom one.

Next we justified our decision on the selected graph library used by the program, and went through the most important steps of the  graph algorithm one-by-one: cost graph calculation, forest building and decomposition.

Then we have shown a code listing for a full run of the anonymizer program for a small sample data table, and illustrated a possible result. Finally we briefly looked at how the continuous mode works for the anonymizer, and when we can take advantage of it.

In the next chapter we will talk about testing, performance and benchmarks.